// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/trophyso/trophy-go/internal"
	time "time"
)

type PointsSummaryRequest struct {
	// Optional colon-delimited user attribute filters in the format attribute:value,attribute:value. Only users matching ALL specified attributes will be included in the points breakdown.
	UserAttributes *string `json:"-" url:"userAttributes,omitempty"`
}

type PointsRange struct {
	// The start of the points range. Inclusive.
	From int `json:"from" url:"from"`
	// The end of the points range. Inclusive.
	To int `json:"to" url:"to"`
	// The number of users in this points range.
	Users int `json:"users" url:"users"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PointsRange) GetFrom() int {
	if p == nil {
		return 0
	}
	return p.From
}

func (p *PointsRange) GetTo() int {
	if p == nil {
		return 0
	}
	return p.To
}

func (p *PointsRange) GetUsers() int {
	if p == nil {
		return 0
	}
	return p.Users
}

func (p *PointsRange) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PointsRange) UnmarshalJSON(data []byte) error {
	type unmarshaler PointsRange
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PointsRange(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PointsRange) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// A list of eleven points ranges, with the first starting and ending at 0, and the remaining 10 being calculated as 10 equally sized ranges from 1 to the greatest number of points a user has, rounded up to the nearest power of 10.
type PointsSummaryResponse = []*PointsRange

type PointsSystemResponse struct {
	// The unique ID of the points system.
	Id string `json:"id" url:"id"`
	// The name of the points system.
	Name string `json:"name" url:"name"`
	// The description of the points system.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The URL of the badge image for the points system, if one has been uploaded.
	BadgeUrl *string `json:"badgeUrl,omitempty" url:"badgeUrl,omitempty"`
	// The maximum number of points a user can be awarded in this points system
	MaxPoints *float64 `json:"maxPoints,omitempty" url:"maxPoints,omitempty"`
	// Array of active triggers for this points system.
	Triggers []*PointsTriggerResponse `json:"triggers,omitempty" url:"triggers,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PointsSystemResponse) GetId() string {
	if p == nil {
		return ""
	}
	return p.Id
}

func (p *PointsSystemResponse) GetName() string {
	if p == nil {
		return ""
	}
	return p.Name
}

func (p *PointsSystemResponse) GetDescription() *string {
	if p == nil {
		return nil
	}
	return p.Description
}

func (p *PointsSystemResponse) GetBadgeUrl() *string {
	if p == nil {
		return nil
	}
	return p.BadgeUrl
}

func (p *PointsSystemResponse) GetMaxPoints() *float64 {
	if p == nil {
		return nil
	}
	return p.MaxPoints
}

func (p *PointsSystemResponse) GetTriggers() []*PointsTriggerResponse {
	if p == nil {
		return nil
	}
	return p.Triggers
}

func (p *PointsSystemResponse) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PointsSystemResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PointsSystemResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PointsSystemResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PointsSystemResponse) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PointsTriggerResponse struct {
	// The unique ID of the trigger.
	Id string `json:"id" url:"id"`
	// The type of trigger.
	Type PointsTriggerResponseType `json:"type" url:"type"`
	// The points awarded by this trigger.
	Points int `json:"points" url:"points"`
	// The status of the trigger.
	Status PointsTriggerResponseStatus `json:"status" url:"status"`
	// The unique ID of the achievement associated with this trigger, if the trigger is an achievement.
	AchievementId *string `json:"achievementId,omitempty" url:"achievementId,omitempty"`
	// The unique ID of the metric associated with this trigger, if the trigger is a metric.
	MetricId *string `json:"metricId,omitempty" url:"metricId,omitempty"`
	// The amount that a user must increase the metric to earn the points, if the trigger is a metric.
	MetricThreshold *int `json:"metricThreshold,omitempty" url:"metricThreshold,omitempty"`
	// The number of consecutive streak periods that a user must complete to earn the points, if the trigger is a streak.
	StreakLengthThreshold *int `json:"streakLengthThreshold,omitempty" url:"streakLengthThreshold,omitempty"`
	// The name of the metric associated with this trigger, if the trigger is a metric.
	MetricName *string `json:"metricName,omitempty" url:"metricName,omitempty"`
	// The name of the achievement associated with this trigger, if the trigger is an achievement.
	AchievementName *string `json:"achievementName,omitempty" url:"achievementName,omitempty"`
	// The time unit of the trigger, if the trigger is a time interval.
	TimeUnit *PointsTriggerResponseTimeUnit `json:"timeUnit,omitempty" url:"timeUnit,omitempty"`
	// The interval of the trigger in the time unit, if the trigger is a time interval.
	TimeInterval *int `json:"timeInterval,omitempty" url:"timeInterval,omitempty"`
	// User attribute filters that must be met for this trigger to activate. Only present if the trigger has user attribute filters configured.
	UserAttributes []*PointsTriggerResponseUserAttributesItem `json:"userAttributes,omitempty" url:"userAttributes,omitempty"`
	// Event attribute filter that must be met for this trigger to activate. Only present if the trigger has an event filter configured.
	EventAttribute *PointsTriggerResponseEventAttribute `json:"eventAttribute,omitempty" url:"eventAttribute,omitempty"`
	// The date and time the trigger was created, in ISO 8601 format.
	Created time.Time `json:"created" url:"created"`
	// The date and time the trigger was last updated, in ISO 8601 format.
	Updated time.Time `json:"updated" url:"updated"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PointsTriggerResponse) GetId() string {
	if p == nil {
		return ""
	}
	return p.Id
}

func (p *PointsTriggerResponse) GetType() PointsTriggerResponseType {
	if p == nil {
		return ""
	}
	return p.Type
}

func (p *PointsTriggerResponse) GetPoints() int {
	if p == nil {
		return 0
	}
	return p.Points
}

func (p *PointsTriggerResponse) GetStatus() PointsTriggerResponseStatus {
	if p == nil {
		return ""
	}
	return p.Status
}

func (p *PointsTriggerResponse) GetAchievementId() *string {
	if p == nil {
		return nil
	}
	return p.AchievementId
}

func (p *PointsTriggerResponse) GetMetricId() *string {
	if p == nil {
		return nil
	}
	return p.MetricId
}

func (p *PointsTriggerResponse) GetMetricThreshold() *int {
	if p == nil {
		return nil
	}
	return p.MetricThreshold
}

func (p *PointsTriggerResponse) GetStreakLengthThreshold() *int {
	if p == nil {
		return nil
	}
	return p.StreakLengthThreshold
}

func (p *PointsTriggerResponse) GetMetricName() *string {
	if p == nil {
		return nil
	}
	return p.MetricName
}

func (p *PointsTriggerResponse) GetAchievementName() *string {
	if p == nil {
		return nil
	}
	return p.AchievementName
}

func (p *PointsTriggerResponse) GetTimeUnit() *PointsTriggerResponseTimeUnit {
	if p == nil {
		return nil
	}
	return p.TimeUnit
}

func (p *PointsTriggerResponse) GetTimeInterval() *int {
	if p == nil {
		return nil
	}
	return p.TimeInterval
}

func (p *PointsTriggerResponse) GetUserAttributes() []*PointsTriggerResponseUserAttributesItem {
	if p == nil {
		return nil
	}
	return p.UserAttributes
}

func (p *PointsTriggerResponse) GetEventAttribute() *PointsTriggerResponseEventAttribute {
	if p == nil {
		return nil
	}
	return p.EventAttribute
}

func (p *PointsTriggerResponse) GetCreated() time.Time {
	if p == nil {
		return time.Time{}
	}
	return p.Created
}

func (p *PointsTriggerResponse) GetUpdated() time.Time {
	if p == nil {
		return time.Time{}
	}
	return p.Updated
}

func (p *PointsTriggerResponse) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PointsTriggerResponse) UnmarshalJSON(data []byte) error {
	type embed PointsTriggerResponse
	var unmarshaler = struct {
		embed
		Created *internal.DateTime `json:"created"`
		Updated *internal.DateTime `json:"updated"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PointsTriggerResponse(unmarshaler.embed)
	p.Created = unmarshaler.Created.Time()
	p.Updated = unmarshaler.Updated.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PointsTriggerResponse) MarshalJSON() ([]byte, error) {
	type embed PointsTriggerResponse
	var marshaler = struct {
		embed
		Created *internal.DateTime `json:"created"`
		Updated *internal.DateTime `json:"updated"`
	}{
		embed:   embed(*p),
		Created: internal.NewDateTime(p.Created),
		Updated: internal.NewDateTime(p.Updated),
	}
	return json.Marshal(marshaler)
}

func (p *PointsTriggerResponse) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Event attribute filter that must be met for this trigger to activate. Only present if the trigger has an event filter configured.
type PointsTriggerResponseEventAttribute struct {
	// The key of the event attribute.
	Key string `json:"key" url:"key"`
	// The required value of the event attribute.
	Value string `json:"value" url:"value"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PointsTriggerResponseEventAttribute) GetKey() string {
	if p == nil {
		return ""
	}
	return p.Key
}

func (p *PointsTriggerResponseEventAttribute) GetValue() string {
	if p == nil {
		return ""
	}
	return p.Value
}

func (p *PointsTriggerResponseEventAttribute) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PointsTriggerResponseEventAttribute) UnmarshalJSON(data []byte) error {
	type unmarshaler PointsTriggerResponseEventAttribute
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PointsTriggerResponseEventAttribute(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PointsTriggerResponseEventAttribute) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// The status of the trigger.
type PointsTriggerResponseStatus string

const (
	PointsTriggerResponseStatusActive   PointsTriggerResponseStatus = "active"
	PointsTriggerResponseStatusArchived PointsTriggerResponseStatus = "archived"
)

func NewPointsTriggerResponseStatusFromString(s string) (PointsTriggerResponseStatus, error) {
	switch s {
	case "active":
		return PointsTriggerResponseStatusActive, nil
	case "archived":
		return PointsTriggerResponseStatusArchived, nil
	}
	var t PointsTriggerResponseStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PointsTriggerResponseStatus) Ptr() *PointsTriggerResponseStatus {
	return &p
}

// The time unit of the trigger, if the trigger is a time interval.
type PointsTriggerResponseTimeUnit string

const (
	PointsTriggerResponseTimeUnitHour PointsTriggerResponseTimeUnit = "hour"
	PointsTriggerResponseTimeUnitDay  PointsTriggerResponseTimeUnit = "day"
)

func NewPointsTriggerResponseTimeUnitFromString(s string) (PointsTriggerResponseTimeUnit, error) {
	switch s {
	case "hour":
		return PointsTriggerResponseTimeUnitHour, nil
	case "day":
		return PointsTriggerResponseTimeUnitDay, nil
	}
	var t PointsTriggerResponseTimeUnit
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PointsTriggerResponseTimeUnit) Ptr() *PointsTriggerResponseTimeUnit {
	return &p
}

// The type of trigger.
type PointsTriggerResponseType string

const (
	PointsTriggerResponseTypeMetric       PointsTriggerResponseType = "metric"
	PointsTriggerResponseTypeAchievement  PointsTriggerResponseType = "achievement"
	PointsTriggerResponseTypeStreak       PointsTriggerResponseType = "streak"
	PointsTriggerResponseTypeTime         PointsTriggerResponseType = "time"
	PointsTriggerResponseTypeUserCreation PointsTriggerResponseType = "user_creation"
)

func NewPointsTriggerResponseTypeFromString(s string) (PointsTriggerResponseType, error) {
	switch s {
	case "metric":
		return PointsTriggerResponseTypeMetric, nil
	case "achievement":
		return PointsTriggerResponseTypeAchievement, nil
	case "streak":
		return PointsTriggerResponseTypeStreak, nil
	case "time":
		return PointsTriggerResponseTypeTime, nil
	case "user_creation":
		return PointsTriggerResponseTypeUserCreation, nil
	}
	var t PointsTriggerResponseType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PointsTriggerResponseType) Ptr() *PointsTriggerResponseType {
	return &p
}

type PointsTriggerResponseUserAttributesItem struct {
	// The key of the user attribute.
	Key string `json:"key" url:"key"`
	// The value of the user attribute.
	Value string `json:"value" url:"value"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PointsTriggerResponseUserAttributesItem) GetKey() string {
	if p == nil {
		return ""
	}
	return p.Key
}

func (p *PointsTriggerResponseUserAttributesItem) GetValue() string {
	if p == nil {
		return ""
	}
	return p.Value
}

func (p *PointsTriggerResponseUserAttributesItem) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PointsTriggerResponseUserAttributesItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PointsTriggerResponseUserAttributesItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PointsTriggerResponseUserAttributesItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PointsTriggerResponseUserAttributesItem) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}
